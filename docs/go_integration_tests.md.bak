# Go Integration Tests Documentation

This document details the implementation approach, operating principles, and how to add new test cases for the Go integration tests located in the `tests` directory.

## 1. Implementation Approach

The core objective of the Integration tests is to perform Black-box Testing on the `nimbis` server. We do not directly test the internal functions of the Rust code; instead, we compile `nimbis` into a binary, run it, and interact with it via the Redis protocol to verify if its behavior meets expectations.

### Tech Stack
- **Testing Framework**: [Ginkgo v2](https://onsi.github.io/ginkgo/) is used as the BDD (Behavior-Driven Development) style testing framework.
- **Assertion Library**: [Gomega](https://onsi.github.io/gomega/) is used for assertions.
- **Redis Client**: [go-redis/v9](https://github.com/redis/go-redis) is used as the client to interact with the server.

### Lifecycle Management
The Test Suite is responsible for managing the lifecycle of the `nimbis` server process:
1.  **BeforeSuite**: Automatically compiles or finds the `nimbis` binary, starts the server process, and waits for it to be ready (via Ping probe).
2.  **During Tests**: Each test case sends Redis commands via TCP connection and verifies the response.
3.  **AfterSuite**: Sends a signal to kill the server process and cleans up resources.

## 2. Operating Principle

`tests/util/server.go` encapsulates the core logic of service management.

### Binary Discovery
The test program attempts to find the `nimbis` executable in the following order:
1.  **Environment Variable**: Checks the path specified by the `NIMBIS_BIN` environment variable.
2.  **Default Build Path**: Automatically finds the project root (by looking upwards for `Cargo.toml`) and looks for the binary in the approximate path `target/debug/nimbis`.
    - *Hint*: Please ensure `cargo build` or `just build` has been executed before running tests.

### Server Startup Process
1.  `util.StartServer()` starts a subprocess (`os/exec`) to run `nimbis`.
2.  Sets the working directory to the project root to ensure the server can correctly load configuration files or data directories (e.g., `nimbis_data`).
3.  Redirects the server's `Stdout` and `Stderr` to the test process's standard output for easy debugging.
4.  **Health Check**: After startup, the test program loops to try sending `PING` commands to `localhost:6379`. Only after receiving a `PONG` response does it consider the server successfully started and begins executing tests; otherwise, it reports an error after a timeout.

## 3. How to Add New Tests

To add new tests in the `tests` directory, please follow these steps:

### 1. Create Test File
Create a new file ending with `_test.go` in the `tests` directory, for example `list_test.go`.

### 2. Define Test Structure
Use Ginkgo's `Describe`, `Context`, and `It` structures to organize your tests.

```go
package tests

import (
	"context"

	"github.com/marsevilspirit/nimbis/tests/util"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"github.com/redis/go-redis/v9"
)

var _ = Describe("List Commands", func() {
	var rdb *redis.Client
	var ctx context.Context

	// Setup runs before each test case
	BeforeEach(func() {
		rdb = util.NewClient() // Get a new Redis client connection
		ctx = context.Background()
		
		// Optional: Clear database or reset state
		// rdb.FlushDB(ctx) 
	})

	// Cleanup runs after each test case
	AfterEach(func() {
		Expect(rdb.Close()).To(Succeed())
	})

	// Specific test scenarios
	It("should push and pop elements", func() {
		key := "mylist"
		
		// Perform operations
		err := rdb.LPush(ctx, key, "world").Err()
		Expect(err).NotTo(HaveOccurred())
		
		err = rdb.LPush(ctx, key, "hello").Err()
		Expect(err).NotTo(HaveOccurred())

		// Verify results
		val, err := rdb.LPop(ctx, key).Result()
		Expect(err).NotTo(HaveOccurred())
		Expect(val).To(Equal("hello"))
	})
})
```

### 3. Run Tests
Use the Justfile in the project root:
```bash
just e2e-test
```

## 4. Current Test Coverage

The current integration tests cover the following functional areas of the Nimbis server. Each area is tested in a dedicated file within the `tests/` directory.

### 4.1 String Commands (`string_test.go`)
- **GET / SET**: Verification of basic string storage and retrieval.
- **Missing Keys**: Ensures `GET` returns `nil` for non-existent keys.

### 4.2 Hash Commands (`hash_test.go`)
- **HSET**: Supports single and multiple field-value pairs setting.
- **HGET**: Retrieval of individual field values.
- **HMGET**: Retrieval of multiple field values in one command.
- **HGETALL**: Retrieval of all fields and values in a hash.
- **HLEN**: Correct calculation of the number of fields in a hash.
- **Updates**: Verifies that updating existing fields overwrites values but maintains field count.

### 4.3 Key Deletion (`delele_test.go`)
- **String Deletion**: Deleting single and multiple string keys.
- **Hash Deletion**: Deleting hash keys (ensures underlying fields are cleaned up).
- **Mixed Deletion**: Deleting a mix of string, hash, and non-existent keys in a single command.
- **Return Value**: Verifies `DEL` returns the correct count of actually deleted keys.

### 4.4 Configuration (`config_test.go`)
- **CONFIG GET**:
  - Exact match (e.g., `addr`, `data_path`).
  - Wildcard support (`*`, `prefix*`, `*suffix`).
  - Handling of non-existent fields.
- **CONFIG SET**:
  - Verification of immutable fields protection (`addr`, `data_path` cannot be changed at runtime).
  - Error reporting for unknown fields.

### 4.5 Type Conflict Handling (`conflict_key_test.go`)
This suite ensures Nimbis behaves correctly (like Redis) when multiple data types share the same key namespace.

- **String vs Hash Conflicts**:
  - `HSET` on an existing String key -> Returns `WRONGTYPE` error (does not overwrite).
  - `GET` on an existing Hash key -> Returns `WRONGTYPE` error.
- **Type Overwrite (SET)**:
  - `SET` command forces overwrite of any existing key type (including Hash).
  - Verifies that when a Hash is overwritten by a String, the old Hash fields are properly cleaned up and inaccessible.
- **DEL and Type Reuse**:
  - Verifies a key can be reused for a different type after being deleted (e.g., String -> DEL -> Hash).
- **Edge Cases**:
  - Empty string values.
  - Keys with special characters (Unicode, Emoji).

### 4.6 Expire and TTL (`expire_test.go`)
- **Basic Expiration**: Verifies that String and Hash keys are deleted after the specified timeout.
- **TTL Return Values**: 
  - Returns remaining seconds for active keys.
  - Returns `-1` for keys without an expiration.
  - Returns `-2` for non-existent keys.
- **Expiration Updates**: Verifies that setting a new expiration on an existing key updates the timeout.
- **Lazy Delete Verification**: Ensures that keys become inaccessible immediately upon expiration.


### 4.7 List Commands (`list_test.go`)
- **LPUSH / RPUSH**: Adding elements to the left/right of a list.
- **LPOP / RPOP**: Removing and retrieving elements from both ends.
  - Single element pop.
  - Multiple elements pop (count parameter).
- **LRANGE**: Retrieving a range of elements.
  - Positive indices.
  - Negative indices.
  - Full range (`0 -1`).
- **LLEN**: Getting the length of a list.
- **Edge Cases**:
  - Operations on non-existent keys.
  - Pop from empty list.

### 4.8 Set Commands (`set_test.go`)
- **SADD**: Adding members to a set.
  - Single and multiple members.
  - Duplicate handling (idempotent).
- **SREM**: Removing members from a set.
- **SMEMBERS**: Retrieving all members.
- **SISMEMBER**: Checking membership.
- **SCARD**: Getting the cardinality (number of members).
- **Edge Cases**:
  - Operations on non-existent keys.
  - Empty sets.

### 4.9 Sorted Set (ZSet) Commands (`zset_test.go`)
- **ZADD**: Adding members with scores.
  - Single and multiple members.
  - Score updates (same member, different score).
  - Return value verification (count of new members added).
- **ZRANGE**: Retrieving members by rank range.
  - Basic range queries (`0 -1` for all members).
  - Ordered by score verification.
  - `WITHSCORES` option support.
- **ZSCORE**: Getting the score of a member.
  - Existing members.
  - Non-existent members (returns `nil`).
- **ZREM**: Removing members.
  - Single and multiple members.
  - Return value verification.
- **ZCARD**: Getting the number of members.
- **Edge Cases**:
  - Operations on non-existent keys.
  - Negative, zero, and positive scores.
  - Score precision.

### 4.10 Collision Tests (`collision_test.go`)
- **Prefix Collision Prevention**: Ensures that different keys with common prefixes don't interfere with each other.
  - Hash fields: Tests keys like `user` and `user1` coexist without collision.
  - Set members: Verifies member isolation across different sets.
  - List elements: Ensures list operations maintain correct boundaries.
  - ZSet members: Verifies sorted set member and score index separation.
- **Length-Prefixed Encoding**: Validates that the key encoding scheme (using length prefixes) prevents ambiguity.

